/* !
@file       glpbo.cpp
@author     pghali@digipen.edu
@co-author	w.mancong@digipen.edu
@date       26/06/2022

This file contains the declaration of structure GLPbo that encapsulates the
functionality required to stream images generated by a 3D graphics pipe
emulator executed on the CPU for display by the GPU.
*//*__________________________________________________________________________*/
#include "glpbo.h"
double fps = 0.0;

GLsizei GLPbo::width = 0, GLPbo::height = 0;
GLsizei GLPbo::pixel_cnt = 0, GLPbo::byte_cnt = 0;
GLPbo::Color *GLPbo::ptr_to_pbo = nullptr;
GLuint GLPbo::vaoid, GLPbo::elem_cnt, GLPbo::pboid, GLPbo::texid;
GLSLShader GLPbo::shdr_pgm;
GLPbo::Color GLPbo::clear_clr;

/*  _________________________________________________________________________ */
/*!	emulate

@param	none

@return none

get a pointer to the pixel buffer object and changes the color every frame
*/
void GLPbo::emulate()
{
	GLubyte r = static_cast<GLubyte>(std::abs(static_cast<float>(glm::sin(glfwGetTime() * 0.75f))) * 255),
			g = static_cast<GLubyte>(std::abs(static_cast<float>(glm::cos(glfwGetTime() * 0.5f ))) * 255);
	set_clear_color(r, g, 0, 255);
	ptr_to_pbo = static_cast<Color*>(glMapNamedBuffer(pboid, GL_WRITE_ONLY));
	clear_color_buffer();
	glUnmapNamedBuffer(pboid);

	glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pboid);
	glTextureSubImage2D(texid, 0, 0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);
}

/*  _________________________________________________________________________ */
/*! draw_fullwindow_quad

@param	none

@return none

draw function to see color changes on the screen every frame
*/
void GLPbo::draw_fullwindow_quad()
{
	std::ostringstream oss;
	static double time = 1.0;
	time += GLHelper::delta_time;

	if (1.0 < time)
	{
		fps = GLHelper::delta_time < 0.0001 ? 0.0 : 1.0 / GLHelper::delta_time;
		time = 0.0;
	}

	oss << std::fixed << std::setprecision(2) << "Tutorial 6 | Wong Man Cong | PBO size: " << width << " x " << height <<
		" | FPS: " << fps;

	glfwSetWindowTitle(GLHelper::ptr_window, oss.str().c_str());

	glBindTextureUnit(0, texid);
	glTextureParameteri(texid, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTextureParameteri(texid, GL_TEXTURE_WRAP_T, GL_REPEAT);

	shdr_pgm.Use();

	GLuint tex_loc = glGetUniformLocation(shdr_pgm.GetHandle(), "uTex2d");
	glUniform1i(tex_loc, 0);

	glBindVertexArray(vaoid);
	glDrawElements(GL_TRIANGLE_STRIP, elem_cnt, GL_UNSIGNED_SHORT, nullptr);
	glBindVertexArray(0);

	shdr_pgm.UnUse();
}

/*  _________________________________________________________________________ */
/*! init

@param	w: width of glfw window
		h: height of glfw window

@return none

Initialisation of GLPbo application
*/
void GLPbo::init(GLsizei w, GLsizei h)
{
	pixel_cnt = w * h, byte_cnt = pixel_cnt * 4;
	width	  = w, height = h;

	set_clear_color(255, 255, 255, 255);

	glCreateTextures(GL_TEXTURE_2D, 1, &texid);
	glTextureStorage2D(texid, 1, GL_RGBA8, width, height);

	glCreateBuffers(1, &pboid);
	glNamedBufferStorage(pboid, byte_cnt, nullptr, GL_DYNAMIC_STORAGE_BIT | GL_MAP_WRITE_BIT);

	setup_quad_vao();
	setup_shdrpgm();
}

/*  _________________________________________________________________________ */
/*! setup_quad_vao

@param	none

@return none

create a buffer object to render a quad and bind it to vaoid 
*/
void GLPbo::setup_quad_vao()
{
	std::vector<glm::vec2> pos_vtx
	{
		glm::vec2(-1.0f, -1.0f), glm::vec2(1.0f, -1.0f),
		glm::vec2( 1.0f,  1.0f), glm::vec2(-1.0f, 1.0f)
	}, tex_vtx
	{
		glm::vec2(0.0f, 0.0f), glm::vec2(1.0f, 0.0f),
		glm::vec2(1.0f, 1.0f), glm::vec2(0.0f, 1.0f)
	};

	GLuint vbo = 0, ebo = 0;
	glCreateBuffers(1, &vbo);
	glNamedBufferStorage(vbo, sizeof(glm::vec2) * pos_vtx.size() + sizeof(glm::vec2) * tex_vtx.size(), nullptr, GL_DYNAMIC_STORAGE_BIT | GL_MAP_WRITE_BIT);
	glNamedBufferSubData(vbo, 0, sizeof(glm::vec2) * pos_vtx.size(), pos_vtx.data());
	glNamedBufferSubData(vbo, sizeof(glm::vec2) * pos_vtx.size(), sizeof(glm::vec2) * tex_vtx.size(), tex_vtx.data());

	glCreateVertexArrays(1, &vaoid);
	// position attribute
	glEnableVertexArrayAttrib(vaoid, 0);
	glVertexArrayVertexBuffer(vaoid, 0, vbo, 0, sizeof(glm::vec2));
	glVertexArrayAttribFormat(vaoid, 0, 2, GL_FLOAT, GL_FALSE, 0);
	glVertexArrayAttribBinding(vaoid, 0, 0);

	// texture attribute
	glEnableVertexArrayAttrib(vaoid, 1);
	glVertexArrayVertexBuffer(vaoid, 1, vbo, sizeof(glm::vec2) * pos_vtx.size(), sizeof(glm::vec2));
	glVertexArrayAttribFormat(vaoid, 1, 2, GL_FLOAT, GL_FALSE, 0);
	glVertexArrayAttribBinding(vaoid, 1, 1);

	// ebo
	std::vector<GLushort> idx_vtx{ 1, 2, 0, 3 };
	glCreateBuffers(1, &ebo);
	glNamedBufferStorage(ebo, sizeof(GLushort) * idx_vtx.size(), reinterpret_cast<GLvoid*>(idx_vtx.data()), GL_DYNAMIC_STORAGE_BIT);
	glVertexArrayElementBuffer(vaoid, ebo);

	elem_cnt = idx_vtx.size();

	// unbind vao to prevent unwanted changes
	glBindVertexArray(0);
}

/*  _________________________________________________________________________ */
/*! setup_shdrpgm

@param	none

@return none

using c++ string to setup a simple shader program for vertex and fragment
*/
void GLPbo::setup_shdrpgm()
{
	std::string vtx =
		"#version 450 core\n"
		"layout(location = 0) in vec2 aPos;\n"
		"layout(location = 2) in vec2 aTexCoords;\n"
		"layout(location = 0) out vec2 vTexCoords;\n"
		"void main()\n"
		"{\n"
		"gl_Position = vec4(aPos, 0.0f, 1.0f);\n"
		"vTexCoords = aTexCoords;\n"
		"}\n";
	std::string frg =
		"#version 450 core\n"
		"layout(location = 0) in vec2 vTexCoords;\n"
		"layout(location = 0) out vec4 fColor;\n"
		"uniform sampler2D uTex2d;\n"
		"void main()\n"
		"{\n"
		"fColor = texture(uTex2d, vTexCoords);\n"
		"}\n";

	shdr_pgm.CompileShaderFromString(GL_VERTEX_SHADER,	 vtx);
	shdr_pgm.CompileShaderFromString(GL_FRAGMENT_SHADER, frg);
	shdr_pgm.Link();
	shdr_pgm.Validate();
}

/*  _________________________________________________________________________ */
/*! cleanup

@param	none

@return none

return resources back to gpu
*/
void GLPbo::cleanup()
{
	glDeleteVertexArrays(1, &vaoid);
	glDeleteBuffers(1, &pboid);
	glDeleteTextures(1, &texid);
}

/*  _________________________________________________________________________ */
/*!	set_clear_color

@param	clr: value containing the new color

@return none

set the value for clear color
*/
void GLPbo::set_clear_color(GLPbo::Color clr)
{
	clear_clr = clr;
}

/*  _________________________________________________________________________ */
/*! set_clear_color

@param	r: unsigned value for red color
		g: unsigned value for green	color
		b: unsigned value for blue color
		a: unsigned value for alpha

@return none

set the value for clear_color
*/
void GLPbo::set_clear_color(GLubyte r, GLubyte g, GLubyte b, GLubyte a)
{
	clear_clr.r = r, clear_clr.g = g, clear_clr.b = b, clear_clr.a = a;
}

/*  _________________________________________________________________________ */
/*! clear_color_buffer

@param	none

@return none

function similar to glClear which fills the buffer with the specified clear_clr
*/
void GLPbo::clear_color_buffer()
{
	std::fill_n(ptr_to_pbo, pixel_cnt, clear_clr);
}