/* !
@file       glpbo.cpp
@author     pghali@digipen.edu
@co-author	w.mancong@digipen.edu
@date       16/07/2022

This file contains function definition for rendering a 3D model of an ogre and
a cube. It uses the bresenham algorithm to render the models in wireframe mode
and triangle edge equation to determine if a fragment should exist in a triangle
when rendering for triangles. This program have 7 different rendering mode.
*//*__________________________________________________________________________*/

/*                                                                      guard
----------------------------------------------------------------------------- */
#ifndef GLPBO_H
#define GLPBO_H

/*                                                                   includes
----------------------------------------------------------------------------- */
#include <GL/glew.h> // for access to OpenGL API declarations 
#include <glslshader.h> // GLSLShader class definition
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp> 
#include <dpml.h>
#include <glhelper.h>
#include <vector>
#include <algorithm>
#include <fstream>
#include <iomanip>
#include <random>

/*  _________________________________________________________________________ */
struct GLPbo
  /*! GLPbo structure to encapsulate 3D graphics pipe emulator which will write
  an image composed of 32-bit RGBA values to PBO, copy the image from PBO to image 
  store of a texture object, and finally use this texture image to render a 
  full-window quad that will display the emulator's output (phew).
  */
{
  // forward declaration
  union Color;

  //-------------- static member function declarations here -----------------
  
  // this is where the emulator does its work of emulating the graphics pipe
  // it generates images using set_pixel to write to the PBO
  static void emulate();
  
  // render quad using the texture image generated by emulate()
  // also prints appropriate information to window's title bar ...
  static void draw_fullwindow_quad();

  // initialization and cleanup stuff ...
  static void init(GLsizei w, GLsizei h);
  static void setup_quad_vao();
  static void setup_shdrpgm();
  static void cleanup();

  // ---------------static data members are declared here ----------------
  
  // Storage requirements common to emulator, PBO and texture object
  static GLsizei width, height; // dimensions of buffers
  // rather than computing these values many times, compute once in
  // GLPbo::init() and then forget ...
  static GLsizei pixel_cnt, byte_cnt; // how many pixels and bytes
  // pointer to PBO's data store - must be set every frame with  
  // the value returned by glMapNamedBuffer()
  static Color *ptr_to_pbo;

  // geometry and material information ...
  static GLuint     vaoid;          // with GL 4.5, VBO & EBO are not required
  static GLuint     elem_cnt;       // how many indices in element buffer
  static GLuint     pboid;          // id for PBO
  static GLuint     texid;          // id for texture object
  static GLSLShader shdr_pgm;       // object that abstracts away nitty-gritty
                                    // details of shader management

// --- here we're trying to emulate GL's functions for clearing colorbuffer ---

  // overloaded functions akin to glClearcolor that set GLPbo::clear_clr
  // with user-supplied parameters ...
  static void set_clear_color(GLPbo::Color clr);
  static void set_clear_color(GLubyte r, GLubyte g, GLubyte b, GLubyte a = 255);

  // akin to glClear(GL_COLOR_BUFFER_BIT) - uses the pointer ptr_to_pbo
  // to get access to the PBO's data store ...
  static void clear_color_buffer();

  // what value to use for clearing color buffer?
  static Color clear_clr;

  /*! glm doesn't have type unsigned char [4] - therefore we declare our
      own type.
      Since Color is such a common type name in graphics applications, make
      sure to encapsulate the name in scope GLPbo!!!
  */
  union Color
  {
    struct 
    {
      GLubyte r, g, b, a; // a, b, g, r
    };
    GLubyte val[4]; // treat <r,g,b,a> as array of 8-bit unsigned values
    GLuint raw;     // treat <r,g,b,a> as 32-bit unsigned value

    Color(GLubyte re = 0, GLubyte gr = 0, GLubyte bl = 0, GLubyte al = 255) : r(re), g(gr), b(bl), a(al) {}
  };
  
  // assignment 1 functions and variables
  enum class ObjectTypes
  {
      Ogre,
      Cube,
      Total
  };

  enum class RenderMode
  {
      Wireframe,
      Depth_Buffer,
      Faceted,
      Shaded,
      Textured,
      Textured_Faceted,
      Textured_Shaded,
      Total
  };

  struct Object
  {
      std::vector<glm::vec3> pos;       // invariant (never changes)
      std::vector<glm::vec3> nml;       // map from ranges [-1,1] to [0,1]
      std::vector<glm::vec2> tex;       // texture coords
      std::vector<unsigned short> pos_idx;  // position indices
      std::vector<unsigned short> nml_idx;  // position indices
      std::vector<unsigned short> tex_idx;  // position indices

      std::vector<glm::vec3> pd;

      glm::mat4 model{ glm::mat4(1.0f) };
      RenderMode rm{ RenderMode::Wireframe };
      size_t culled{ 0 };
      float angle{ 0.0f };
      bool rotating{ false };
  };

  struct Edge
  {
      float a{ 0.0f }, b{ 0.0 }, c{ 0.0 };
      bool tl{ false };
  };

  struct Triangle
  {
      Edge e0, e1, e2;
  };

  struct PointLight
  {
      glm::vec3 intensity{ 0.0f, 0.0f, 0.0f };
      glm::vec3 position { 0.0f, 0.0f, 0.0f };
  };

  struct Texture
  {
      size_t width{ 0 }, height{ 0 };
      std::vector<Color> texel;
  };

  static Object objs[static_cast<size_t>(ObjectTypes::Total)];
  static float *depth_buffer;

  /*  _________________________________________________________________________ */
  /*! load_scene

  @param	none

  @return none

  load the appropriate objects name in the scene into the project
  */
  static void load_scene();

  /*  _________________________________________________________________________ */
  /*! clear_depth_buffer

  @param	none

  @return none

  clears the depth buffer to store the largest depth value
  */
  static void clear_depth_buffer();

  /*  _________________________________________________________________________ */
  /*! set_pixel_color

  @param	x: x coordinate
          y: y coordinate
          clr: clr at (x,y) coordinate

  @return none

  set a particular color at (x,y) coordinate
  */
  static void set_pixel_color(int x, int y, Color clr);

  /*  _________________________________________________________________________ */
  /*! set_pixel_color

  @param	x: x coordinate
          y: y coordinate
          z: z coordinate
          clr: clr at (x,y) coordinate

  @return none

  set a particular color at (x,y) coordinate, checks with depth buffer before setting the color
  at (x,y) coordinate
  */
  static void set_pixel_color(int x, int y, float z, Color clr);

  /*  _________________________________________________________________________ */
  /*! GetTexel

  @param	coord: interpolated texture coordinate

  @return Color value at coord based on the texture

  Get the texel color based off the interpolated texture coordinates
  */
  static Color GetTexel(glm::vec2 const& coord);

  /*  _________________________________________________________________________ */
  /*! viewport_mtx

  @param	none

  @return none

  helper function to generate a viewport mtx based on the window's width and height
  */
  static void viewport_mtx();

  /*  _________________________________________________________________________ */
  /*! viewport_xform

  @param	none

  @return none

  transform the ndc coordinates to window coordinate
  */
  static void viewport_xform();

  /*  _________________________________________________________________________ */
  /*! model_mtx

  @param	angle: angle of rotation
          av	 : axis vector to rotate about
          s	 : scale value

  @return model matrix based on object's angle, axis of rotation and scale

  Does calculation of model matrix immediately and return a model matrix
  based on object's angle and scale
  */
  static glm::mat4 model_mtx(float angle, glm::vec3 const& av, glm::vec3 const& s);

  static glm::mat4 view_mtx(glm::vec3 pos, glm::vec3 tgt, glm::vec3 up);

  /*  _________________________________________________________________________ */
  /*! triangle_area

  @param	pos: an array of 3 vec2 storing the window coordinate of the triangle

  @return the area of the triangle

  calculate the area of the triangle based on the position of the 3 vertices
  */
  static float triangle_area(glm::vec3 const pos[3]);

  /*  _________________________________________________________________________ */
  /*!	triangle_area

  @param  x0: x coordinate of vertex 0
          y0:	y coordinate of vertex 0
          x1:	x coordinate of vertex 1
          y1:	y coordinate of vertex 1
          x2:	x coordinate of vertex 2
          y2: y coordinate of vertex 2

  @return the area of the triangle

  calculate the area of the triangle based on the position of the vertices
  */
  static float triangle_area(float x0, float y0, float x1, float y1, float x2, float y2);

  /*  _________________________________________________________________________ */
  /*! backface_cull

  @param	area: area of the triangle

  @return true if area is positive, false if negative

  checks if the area is positive or negative
  */
  static bool backface_cull(float area);

  /*  _________________________________________________________________________ */
  /*! backface_cull

  @param	pos: an array of 3 vec2 storing the window coordinate of the triangle

  @return true if area is positive, false if negative

  checks if the area is positive or negative
  */
  static bool backface_cull(glm::vec3 const pos[3]);

  /*  _________________________________________________________________________ */
  /*! wireframe_mode

  @param	none

  @return none

  using the bresenham algorithm, render lines on the screen
  */
  static void wireframe_mode();

  /*  _________________________________________________________________________ */
  /*! render_linebresenham

  @param	x1:	x coordinate of vertex 1 in window coordinate
          y1:	y coordinate of vertex 1 in window coordinate
          x2:	x coordinate of vertex 2 in window coordinate
          y2: y coordinate of vertex 2 in window coordinate
          clr: clr to be set at the (x,y) coordinate

  @return none

  using the bresenham line algorithm, calculate the decision parameter and
  render a line on the screen
  */
  static void render_linebresenham(int x1, int y1, int x2, int y2, Color clr = Color(0, 0, 0));

  /*  _________________________________________________________________________ */
  /*! triangle_mode

  @param	none

  @return none

  using the triangle edge equation formula, determine if a particular
  point on screen should be rendered on screen and rendering a triangle as a result
  */
  static void triangle_mode();

  /*  _________________________________________________________________________ */
  /*! my_own_obj_parser

    @param std::string filename
    The name of the file containing the OBJ geometry information.

    @param std::vector<glm::vec3>& positions
    Fill user-supplied container with vertex position attributes.

    @param std::vector<glm::vec3>& normals
    Fill user-supplied container with vertex normal attributes.
    The container will not be touched if parameter "nml_attribs_flag" is
    false.

    @param std::vector<glm::vec2>& texcoords
    Fill user-supplied container with vertex texture coordinate attributes.
    The container will not be touched if parameter "texcoords_attribs_flag" is
    false.

    @param std::vector<unsigned short>& triangles
    Triangle vertices are specified as indices into containers "positions",
    "normals", and "texcoords". Triangles will always have counter-clockwise
    orientation. This means that when looking at a face from the outside of
    the box, the triangles are counter-clockwise oriented.
    Use an indexed draw call to draw the box.

    @param bool load_tex_coord_flag = false
    If parameter is true, then texture coordinates (if present in file) will
    be parsed. Otherwise, texture coordinate (even if present in file) will
    not be read.

    @param bool load_nml_coord_flag = false
    If parameter is true, then per-vertex normal coordinates (if present in file)
    will be parsed if they are present in file, otherwise, the per-vertex
    normals are computed.
    If the parameter is false, normal coordinate will neither be read from
    file (if present) nor explicitly computed.

    @param bool model_centered_flag = true
    In some cases, the modeler might have generated the model such that the
    center (of gravity) of the model is not centered at the origin.
    If the parameter is true, then the function will compute an axis-aligned
    bounding box and translate the position coordinates so that the box's center
    is at the origin.
    If the parameter is false, the position coordinates are left untouched.

    @return bool
    true if successful, otherwise false.
    The function can return false if the file is not present

    This function parses an OBJ geometry file and stores the contents of the file
    as array of vertex, array of normal (if required), and an array of texture
    (if required) coordinate data. These three arrays will have the same size.
    Triangles are defined as an array of indices into array of position
    coordinates.
  */
  static bool my_own_obj_parser(std::string filename,
      std::vector<glm::vec3>& positions,
      std::vector<glm::vec3>& normals,
      std::vector<glm::vec2>& texcoords,
      std::vector<unsigned short>&  position_indices,
      std::vector<unsigned short>&  normal_indices,
      std::vector<unsigned short>&  texture_indices,
      bool                          load_nml_coord_flag,
      bool                          load_tex_coord_flag,
      bool                          model_centered_flag = true);
};

#endif /* GLPBO_H */
